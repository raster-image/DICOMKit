//
// ParametricMap.swift
// DICOMKit
//
// Created by DICOMKit on 2026-02-05.
// Copyright © 2026 DICOMKit. All rights reserved.
//

import Foundation
import DICOMCore

/// DICOM Parametric Map IOD
///
/// A Parametric Map object represents quantitative imaging data where pixel values
/// encode physical quantities (e.g., ADC, T1/T2 relaxation times, perfusion parameters,
/// SUV). These maps are commonly generated by quantitative imaging tools and require
/// Real World Value Mapping to convert stored pixel values to physical measurements.
///
/// Reference: PS3.3 A.75 - Parametric Map IOD
/// Reference: PS3.3 C.8.23 - Parametric Map Modules
/// Reference: PS3.3 C.7.6.16.2.11 - Real World Value Mapping Functional Group
public struct ParametricMap: Sendable {
    
    // MARK: - Parametric Map Identification
    
    /// SOP Instance UID
    public let sopInstanceUID: String
    
    /// SOP Class UID (should be Parametric Map Storage: 1.2.840.10008.5.1.4.1.1.30)
    public let sopClassUID: String
    
    /// Series Instance UID
    public let seriesInstanceUID: String
    
    /// Study Instance UID
    public let studyInstanceUID: String
    
    /// Instance Number
    public let instanceNumber: Int?
    
    /// Content Label - a label that identifies the content
    public let contentLabel: String?
    
    /// Content Description - human-readable description
    public let contentDescription: String?
    
    /// Content Creator's Name
    public let contentCreatorName: DICOMPersonName?
    
    /// Content Date
    public let contentDate: DICOMDate?
    
    /// Content Time
    public let contentTime: DICOMTime?
    
    // MARK: - Derivation Information
    
    /// Derivation Description - how this map was derived
    public let derivationDescription: String?
    
    /// Derivation Code Sequence - coded description of derivation process
    public let derivationCodeSequence: [CodedEntry]
    
    // MARK: - Quantity Definitions
    
    /// Real World Value Mappings - mappings from stored values to physical quantities
    public let realWorldValueMappings: [RealWorldValueMapping]
    
    // MARK: - Image Reference
    
    /// Frame of Reference UID
    public let frameOfReferenceUID: String?
    
    /// Dimension Organization UID
    public let dimensionOrganizationUID: String?
    
    /// Referenced Series Sequence
    public let referencedSeries: [ParametricMapReferencedSeries]
    
    // MARK: - Pixel Data Properties
    
    /// Number of frames
    public let numberOfFrames: Int
    
    /// Rows
    public let rows: Int
    
    /// Columns
    public let columns: Int
    
    /// Bits Allocated
    public let bitsAllocated: Int
    
    /// Bits Stored
    public let bitsStored: Int
    
    /// High Bit
    public let highBit: Int
    
    /// Samples Per Pixel
    public let samplesPerPixel: Int
    
    /// Photometric Interpretation
    public let photometricInterpretation: String
    
    /// Pixel Representation (0 = unsigned, 1 = signed, 2 = float, 3 = double)
    public let pixelRepresentation: Int
    
    // MARK: - Functional Groups
    
    /// Shared Functional Groups Sequence
    public let sharedFunctionalGroups: FunctionalGroup?
    
    /// Per-Frame Functional Groups Sequence
    public let perFrameFunctionalGroups: [FunctionalGroup]
    
    // MARK: - Initialization
    
    /// Initialize a Parametric Map
    public init(
        sopInstanceUID: String,
        sopClassUID: String = "1.2.840.10008.5.1.4.1.1.30",
        seriesInstanceUID: String,
        studyInstanceUID: String,
        instanceNumber: Int? = nil,
        contentLabel: String? = nil,
        contentDescription: String? = nil,
        contentCreatorName: DICOMPersonName? = nil,
        contentDate: DICOMDate? = nil,
        contentTime: DICOMTime? = nil,
        derivationDescription: String? = nil,
        derivationCodeSequence: [CodedEntry] = [],
        realWorldValueMappings: [RealWorldValueMapping],
        frameOfReferenceUID: String? = nil,
        dimensionOrganizationUID: String? = nil,
        referencedSeries: [ParametricMapReferencedSeries] = [],
        numberOfFrames: Int,
        rows: Int,
        columns: Int,
        bitsAllocated: Int,
        bitsStored: Int,
        highBit: Int,
        samplesPerPixel: Int = 1,
        photometricInterpretation: String = "MONOCHROME2",
        pixelRepresentation: Int = 0,
        sharedFunctionalGroups: FunctionalGroup? = nil,
        perFrameFunctionalGroups: [FunctionalGroup] = []
    ) {
        self.sopInstanceUID = sopInstanceUID
        self.sopClassUID = sopClassUID
        self.seriesInstanceUID = seriesInstanceUID
        self.studyInstanceUID = studyInstanceUID
        self.instanceNumber = instanceNumber
        self.contentLabel = contentLabel
        self.contentDescription = contentDescription
        self.contentCreatorName = contentCreatorName
        self.contentDate = contentDate
        self.contentTime = contentTime
        self.derivationDescription = derivationDescription
        self.derivationCodeSequence = derivationCodeSequence
        self.realWorldValueMappings = realWorldValueMappings
        self.frameOfReferenceUID = frameOfReferenceUID
        self.dimensionOrganizationUID = dimensionOrganizationUID
        self.referencedSeries = referencedSeries
        self.numberOfFrames = numberOfFrames
        self.rows = rows
        self.columns = columns
        self.bitsAllocated = bitsAllocated
        self.bitsStored = bitsStored
        self.highBit = highBit
        self.samplesPerPixel = samplesPerPixel
        self.photometricInterpretation = photometricInterpretation
        self.pixelRepresentation = pixelRepresentation
        self.sharedFunctionalGroups = sharedFunctionalGroups
        self.perFrameFunctionalGroups = perFrameFunctionalGroups
    }
}

// MARK: - RealWorldValueMapping

/// Real World Value Mapping
///
/// Defines how stored pixel values map to physical quantities with units.
/// Can use linear transformation (slope/intercept) or explicit LUT data.
///
/// Reference: PS3.3 C.7.6.16.2.11 - Real World Value Mapping Functional Group
public struct RealWorldValueMapping: Sendable {
    
    /// Label for this mapping
    public let label: String?
    
    /// Explanation of the LUT
    public let explanation: String?
    
    /// Measurement units (UCUM coded entry)
    public let measurementUnits: MeasurementUnits
    
    /// Quantity definition (what physical quantity is being mapped)
    public let quantityDefinition: QuantityDefinition?
    
    /// Mapping method (linear transformation or explicit LUT)
    public let mapping: MappingMethod
    
    /// Initialize a Real World Value Mapping
    public init(
        label: String? = nil,
        explanation: String? = nil,
        measurementUnits: MeasurementUnits,
        quantityDefinition: QuantityDefinition? = nil,
        mapping: MappingMethod
    ) {
        self.label = label
        self.explanation = explanation
        self.measurementUnits = measurementUnits
        self.quantityDefinition = quantityDefinition
        self.mapping = mapping
    }
}

// MARK: - MappingMethod

/// Method for mapping stored values to real world values
public enum MappingMethod: Sendable {
    /// Linear transformation: RealWorldValue = slope * StoredValue + intercept
    case linear(slope: Double, intercept: Double)
    
    /// Explicit LUT data mapping
    case lut(firstValueMapped: Double, lastValueMapped: Double, lutData: [Double])
}

// MARK: - MeasurementUnits

/// Measurement units using UCUM (Unified Code for Units of Measure)
///
/// Reference: PS3.16 CID 83 - Units of Measurement
public struct MeasurementUnits: Sendable {
    
    /// Code value (UCUM unit code)
    public let codeValue: String
    
    /// Coding scheme designator (should be "UCUM")
    public let codingSchemeDesignator: String
    
    /// Code meaning (human-readable unit description)
    public let codeMeaning: String
    
    /// Initialize Measurement Units
    public init(
        codeValue: String,
        codingSchemeDesignator: String = "UCUM",
        codeMeaning: String
    ) {
        self.codeValue = codeValue
        self.codingSchemeDesignator = codingSchemeDesignator
        self.codeMeaning = codeMeaning
    }
    
    // MARK: - Common Units
    
    /// mm²/s (for ADC maps)
    public static let mm2PerSecond = MeasurementUnits(
        codeValue: "mm2/s",
        codeMeaning: "square millimeter per second"
    )
    
    /// ms (for T1/T2 relaxation maps)
    public static let millisecond = MeasurementUnits(
        codeValue: "ms",
        codeMeaning: "millisecond"
    )
    
    /// s (for time measurements)
    public static let second = MeasurementUnits(
        codeValue: "s",
        codeMeaning: "second"
    )
    
    /// g/ml (for SUV maps - standardized uptake value)
    public static let gPerML = MeasurementUnits(
        codeValue: "g/ml",
        codeMeaning: "gram per milliliter"
    )
    
    /// 1/min (for perfusion Ktrans)
    public static let perMinute = MeasurementUnits(
        codeValue: "/min",
        codeMeaning: "per minute"
    )
    
    /// Unitless ratio
    public static let ratio = MeasurementUnits(
        codeValue: "1",
        codeMeaning: "no units"
    )
}

// MARK: - QuantityDefinition

/// Definition of the physical quantity being mapped
///
/// Reference: PS3.3 C.7.6.16.2.11 - Real World Value Mapping
public struct QuantityDefinition: Sendable {
    
    /// Code value identifying the quantity type
    public let codeValue: String
    
    /// Coding scheme designator (typically "DCM" or "SCT")
    public let codingSchemeDesignator: String
    
    /// Code meaning (human-readable quantity name)
    public let codeMeaning: String
    
    /// Initialize a Quantity Definition
    public init(
        codeValue: String,
        codingSchemeDesignator: String,
        codeMeaning: String
    ) {
        self.codeValue = codeValue
        self.codingSchemeDesignator = codingSchemeDesignator
        self.codeMeaning = codeMeaning
    }
    
    // MARK: - Common Quantities
    
    /// Apparent Diffusion Coefficient (ADC)
    public static let adc = QuantityDefinition(
        codeValue: "113041",
        codingSchemeDesignator: "DCM",
        codeMeaning: "Apparent Diffusion Coefficient"
    )
    
    /// T1 relaxation time
    public static let t1 = QuantityDefinition(
        codeValue: "113054",
        codingSchemeDesignator: "DCM",
        codeMeaning: "T1"
    )
    
    /// T2 relaxation time
    public static let t2 = QuantityDefinition(
        codeValue: "113055",
        codingSchemeDesignator: "DCM",
        codeMeaning: "T2"
    )
    
    /// Ktrans (volume transfer constant)
    public static let ktrans = QuantityDefinition(
        codeValue: "126312",
        codingSchemeDesignator: "DCM",
        codeMeaning: "Ktrans"
    )
    
    /// Ve (extravascular extracellular volume fraction)
    public static let ve = QuantityDefinition(
        codeValue: "126313",
        codingSchemeDesignator: "DCM",
        codeMeaning: "Ve"
    )
    
    /// Vp (plasma volume fraction)
    public static let vp = QuantityDefinition(
        codeValue: "126314",
        codingSchemeDesignator: "DCM",
        codeMeaning: "Vp"
    )
    
    /// Standardized Uptake Value (SUV)
    public static let suv = QuantityDefinition(
        codeValue: "126400",
        codingSchemeDesignator: "DCM",
        codeMeaning: "Standardized Uptake Value"
    )
    
    /// SUV body weight (SUVbw)
    public static let suvbw = QuantityDefinition(
        codeValue: "126401",
        codingSchemeDesignator: "DCM",
        codeMeaning: "Standardized Uptake Value body weight"
    )
    
    /// SUV lean body mass (SUVlbm)
    public static let suvlbm = QuantityDefinition(
        codeValue: "126402",
        codingSchemeDesignator: "DCM",
        codeMeaning: "Standardized Uptake Value lean body mass"
    )
    
    /// SUV body surface area (SUVbsa)
    public static let suvbsa = QuantityDefinition(
        codeValue: "126403",
        codingSchemeDesignator: "DCM",
        codeMeaning: "Standardized Uptake Value body surface area"
    )
}

// MARK: - CodedEntry

/// A coded entry (code value, coding scheme, code meaning)
public struct CodedEntry: Sendable {
    
    /// Code value
    public let codeValue: String
    
    /// Coding scheme designator
    public let codingSchemeDesignator: String
    
    /// Code meaning
    public let codeMeaning: String
    
    /// Initialize a coded entry
    public init(
        codeValue: String,
        codingSchemeDesignator: String,
        codeMeaning: String
    ) {
        self.codeValue = codeValue
        self.codingSchemeDesignator = codingSchemeDesignator
        self.codeMeaning = codeMeaning
    }
}

// MARK: - ParametricMapReferencedSeries

/// Referenced Series for Parametric Map
///
/// Links the parametric map to source series from which it was derived
public struct ParametricMapReferencedSeries: Sendable {
    
    /// Series Instance UID of the referenced series
    public let seriesInstanceUID: String
    
    /// Referenced Instance Sequence - instances from the series
    public let referencedInstances: [ReferencedInstance]
    
    /// Initialize a Referenced Series
    public init(
        seriesInstanceUID: String,
        referencedInstances: [ReferencedInstance] = []
    ) {
        self.seriesInstanceUID = seriesInstanceUID
        self.referencedInstances = referencedInstances
    }
}

// MARK: - ReferencedInstance

/// Referenced Instance within a series
public struct ReferencedInstance: Sendable {
    
    /// Referenced SOP Class UID
    public let referencedSOPClassUID: String
    
    /// Referenced SOP Instance UID
    public let referencedSOPInstanceUID: String
    
    /// Referenced Frame Numbers (optional, for multi-frame sources)
    public let referencedFrameNumbers: [Int]
    
    /// Initialize a Referenced Instance
    public init(
        referencedSOPClassUID: String,
        referencedSOPInstanceUID: String,
        referencedFrameNumbers: [Int] = []
    ) {
        self.referencedSOPClassUID = referencedSOPClassUID
        self.referencedSOPInstanceUID = referencedSOPInstanceUID
        self.referencedFrameNumbers = referencedFrameNumbers
    }
}

// Note: FunctionalGroup is already defined in Segmentation.swift and is reused here
