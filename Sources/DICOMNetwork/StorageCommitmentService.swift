import Foundation
import DICOMCore

// MARK: - Storage Commitment SOP Class UIDs

/// Storage Commitment Push Model SOP Class UID
///
/// Used for Storage Commitment requests via N-ACTION and N-EVENT-REPORT.
///
/// Reference: PS3.4 Annex J - Storage Commitment Service Class
public let storageCommitmentPushModelSOPClassUID = "1.2.840.10008.1.20.1"

/// Storage Commitment Push Model SOP Instance UID (Well-Known)
///
/// The well-known SOP Instance UID for the Storage Commitment Push Model.
///
/// Reference: PS3.4 Annex J.3
public let storageCommitmentPushModelSOPInstanceUID = "1.2.840.10008.1.20.1.1"

// MARK: - Storage Commitment Action/Event Type IDs

/// Action Type ID for Storage Commitment Request
///
/// Used in N-ACTION-RQ to request storage commitment.
/// Value: 1 (Request Storage Commitment)
///
/// Reference: PS3.4 Table J.3-1
public let storageCommitmentRequestActionTypeID: UInt16 = 1

/// Event Type ID for Storage Commitment Result - Success
///
/// Used in N-EVENT-REPORT-RQ when all instances are committed.
/// Value: 1 (Storage Commitment Request Successful)
///
/// Reference: PS3.4 Table J.3-2
public let storageCommitmentSuccessEventTypeID: UInt16 = 1

/// Event Type ID for Storage Commitment Result - Failure
///
/// Used in N-EVENT-REPORT-RQ when some instances failed commitment.
/// Value: 2 (Storage Commitment Request Complete - Failures Exist)
///
/// Reference: PS3.4 Table J.3-2
public let storageCommitmentFailureEventTypeID: UInt16 = 2

// MARK: - SOP Reference

/// A reference to a stored SOP Instance
///
/// Represents a single DICOM object by its SOP Class and Instance UIDs.
/// Used in Storage Commitment requests to identify instances to commit.
///
/// Reference: PS3.4 Table J.3-1
public struct SOPReference: Sendable, Hashable {
    /// The SOP Class UID of the referenced instance
    public let sopClassUID: String
    
    /// The SOP Instance UID of the referenced instance
    public let sopInstanceUID: String
    
    /// Creates a SOP reference
    ///
    /// - Parameters:
    ///   - sopClassUID: The SOP Class UID
    ///   - sopInstanceUID: The SOP Instance UID
    public init(sopClassUID: String, sopInstanceUID: String) {
        self.sopClassUID = sopClassUID
        self.sopInstanceUID = sopInstanceUID
    }
}

extension SOPReference: CustomStringConvertible {
    public var description: String {
        "SOPReference(class: \(sopClassUID), instance: \(sopInstanceUID))"
    }
}

// MARK: - Failed SOP Reference

/// A SOP reference with failure information
///
/// Represents a SOP Instance that failed storage commitment, including
/// the reason for failure.
///
/// Reference: PS3.4 Table J.3-2
public struct FailedSOPReference: Sendable, Hashable {
    /// The SOP reference that failed
    public let reference: SOPReference
    
    /// The failure reason code
    ///
    /// Common failure reasons:
    /// - 0x0110: Processing failure
    /// - 0x0112: No such object instance
    /// - 0x0213: Resource limitation
    /// - 0x0122: Referenced SOP Class not supported
    ///
    /// Reference: PS3.4 Table J.3-2
    public let failureReason: UInt16
    
    /// Creates a failed SOP reference
    ///
    /// - Parameters:
    ///   - reference: The SOP reference that failed
    ///   - failureReason: The failure reason code
    public init(reference: SOPReference, failureReason: UInt16) {
        self.reference = reference
        self.failureReason = failureReason
    }
    
    /// Human-readable failure reason description
    public var failureReasonDescription: String {
        switch failureReason {
        case 0x0110:
            return "Processing failure"
        case 0x0112:
            return "No such object instance"
        case 0x0213:
            return "Resource limitation"
        case 0x0122:
            return "Referenced SOP Class not supported"
        case 0x0119:
            return "Class/Instance conflict"
        case 0x0131:
            return "Duplicate SOP Instance"
        default:
            return "Unknown failure reason (0x\(String(format: "%04X", failureReason)))"
        }
    }
}

extension FailedSOPReference: CustomStringConvertible {
    public var description: String {
        "FailedSOPReference(\(reference), reason: \(failureReasonDescription))"
    }
}

// MARK: - Commitment Request

/// A Storage Commitment request
///
/// Represents an outstanding request for storage commitment.
/// Contains the transaction UID and the instances being committed.
///
/// Reference: PS3.4 Annex J.3
public struct CommitmentRequest: Sendable, Hashable {
    /// The unique Transaction UID for this commitment request
    ///
    /// Generated by the SCU and used to correlate requests with results.
    public let transactionUID: String
    
    /// The SOP references being committed
    public let references: [SOPReference]
    
    /// The timestamp when the request was created
    public let timestamp: Date
    
    /// The remote AE title that received the request
    public let remoteAETitle: String
    
    /// Creates a commitment request
    ///
    /// - Parameters:
    ///   - transactionUID: The transaction UID
    ///   - references: The SOP references to commit
    ///   - timestamp: The timestamp (default: now)
    ///   - remoteAETitle: The remote AE title
    public init(
        transactionUID: String,
        references: [SOPReference],
        timestamp: Date = Date(),
        remoteAETitle: String
    ) {
        self.transactionUID = transactionUID
        self.references = references
        self.timestamp = timestamp
        self.remoteAETitle = remoteAETitle
    }
}

extension CommitmentRequest: CustomStringConvertible {
    public var description: String {
        "CommitmentRequest(txn: \(transactionUID), count: \(references.count), ae: \(remoteAETitle))"
    }
}

// MARK: - Commitment Result

/// The result of a Storage Commitment request
///
/// Contains information about which instances were successfully committed
/// and which failed, along with the transaction UID for correlation.
///
/// Reference: PS3.4 Annex J.3
public struct CommitmentResult: Sendable, Hashable {
    /// The Transaction UID that correlates this result with a request
    public let transactionUID: String
    
    /// The SOP references that were successfully committed
    public let committedReferences: [SOPReference]
    
    /// The SOP references that failed commitment
    public let failedReferences: [FailedSOPReference]
    
    /// The timestamp when the result was received
    public let timestamp: Date
    
    /// The remote AE title that sent the result
    public let remoteAETitle: String
    
    /// Whether all instances were successfully committed
    public var isSuccess: Bool {
        failedReferences.isEmpty
    }
    
    /// Whether the commitment was partially successful (some instances committed)
    public var isPartialSuccess: Bool {
        !committedReferences.isEmpty && !failedReferences.isEmpty
    }
    
    /// Whether all instances failed commitment
    public var isFailure: Bool {
        committedReferences.isEmpty && !failedReferences.isEmpty
    }
    
    /// The total number of instances in the result
    public var totalCount: Int {
        committedReferences.count + failedReferences.count
    }
    
    /// Creates a commitment result
    ///
    /// - Parameters:
    ///   - transactionUID: The transaction UID
    ///   - committedReferences: Successfully committed references
    ///   - failedReferences: Failed references with reasons
    ///   - timestamp: The timestamp (default: now)
    ///   - remoteAETitle: The remote AE title
    public init(
        transactionUID: String,
        committedReferences: [SOPReference],
        failedReferences: [FailedSOPReference],
        timestamp: Date = Date(),
        remoteAETitle: String
    ) {
        self.transactionUID = transactionUID
        self.committedReferences = committedReferences
        self.failedReferences = failedReferences
        self.timestamp = timestamp
        self.remoteAETitle = remoteAETitle
    }
}

extension CommitmentResult: CustomStringConvertible {
    public var description: String {
        let status = isSuccess ? "SUCCESS" : (isPartialSuccess ? "PARTIAL" : "FAILED")
        return "CommitmentResult(\(status), txn: \(transactionUID), committed: \(committedReferences.count), failed: \(failedReferences.count))"
    }
}

// MARK: - Storage Commitment Configuration

/// Configuration for the Storage Commitment Service
public struct StorageCommitmentConfiguration: Sendable, Hashable {
    /// The local Application Entity title (calling AE)
    public let callingAETitle: AETitle
    
    /// The remote Application Entity title (called AE)
    public let calledAETitle: AETitle
    
    /// Connection timeout in seconds
    public let timeout: TimeInterval
    
    /// Maximum PDU size to propose
    public let maxPDUSize: UInt32
    
    /// Implementation Class UID for this DICOM implementation
    public let implementationClassUID: String
    
    /// Implementation Version Name (optional)
    public let implementationVersionName: String?
    
    /// Default Implementation Class UID for DICOMKit
    public static let defaultImplementationClassUID = "1.2.826.0.1.3680043.9.7433.1.1"
    
    /// Default Implementation Version Name for DICOMKit
    public static let defaultImplementationVersionName = "DICOMKIT_001"
    
    /// Creates a storage commitment configuration
    ///
    /// - Parameters:
    ///   - callingAETitle: The local AE title
    ///   - calledAETitle: The remote AE title
    ///   - timeout: Connection timeout in seconds (default: 60)
    ///   - maxPDUSize: Maximum PDU size (default: 16KB)
    ///   - implementationClassUID: Implementation Class UID
    ///   - implementationVersionName: Implementation Version Name
    public init(
        callingAETitle: AETitle,
        calledAETitle: AETitle,
        timeout: TimeInterval = 60,
        maxPDUSize: UInt32 = defaultMaxPDUSize,
        implementationClassUID: String = defaultImplementationClassUID,
        implementationVersionName: String? = defaultImplementationVersionName
    ) {
        self.callingAETitle = callingAETitle
        self.calledAETitle = calledAETitle
        self.timeout = timeout
        self.maxPDUSize = maxPDUSize
        self.implementationClassUID = implementationClassUID
        self.implementationVersionName = implementationVersionName
    }
}

#if canImport(Network)

// MARK: - Storage Commitment Service

/// Service for requesting Storage Commitment from a DICOM SCP
///
/// The Storage Commitment Service provides functionality for:
/// - Requesting storage commitment for stored DICOM instances (N-ACTION)
/// - Processing commitment notifications (N-EVENT-REPORT)
/// - Tracking pending commitment requests
///
/// ## Example Usage
///
/// ```swift
/// let callingAE = try AETitle("MY_SCU")
/// let calledAE = try AETitle("PACS")
/// let config = StorageCommitmentConfiguration(
///     callingAETitle: callingAE,
///     calledAETitle: calledAE
/// )
///
/// // Request commitment for stored instances
/// let request = try await StorageCommitmentService.requestCommitment(
///     for: [
///         SOPReference(sopClassUID: ctImageStorageSOPClassUID, sopInstanceUID: "1.2.3.4.5")
///     ],
///     host: "pacs.example.com",
///     port: 104,
///     configuration: config
/// )
///
/// print("Commitment requested: \(request.transactionUID)")
/// ```
///
/// Reference: PS3.4 Annex J - Storage Commitment Service Class
public enum StorageCommitmentService {
    
    /// Requests storage commitment for the specified SOP instances
    ///
    /// Sends an N-ACTION-RQ to the remote SCP requesting commitment for
    /// the specified instances. The SCP will later send an N-EVENT-REPORT
    /// (potentially on a new association) with the commitment result.
    ///
    /// - Parameters:
    ///   - references: The SOP references to commit
    ///   - host: The remote host address
    ///   - port: The remote port number (default: 104)
    ///   - configuration: The service configuration
    /// - Returns: A `CommitmentRequest` representing the pending commitment
    /// - Throws: `DICOMNetworkError` if the request fails
    ///
    /// Reference: PS3.4 Section J.3.1 - N-ACTION Service
    public static func requestCommitment(
        for references: [SOPReference],
        host: String,
        port: UInt16 = dicomDefaultPort,
        configuration: StorageCommitmentConfiguration
    ) async throws -> CommitmentRequest {
        guard !references.isEmpty else {
            throw DICOMNetworkError.encodingFailed("At least one SOP reference is required")
        }
        
        // Generate a unique Transaction UID
        let transactionUID = UIDGenerator.generateUID().value
        
        // Create association configuration
        let associationConfig = AssociationConfiguration(
            callingAETitle: configuration.callingAETitle,
            calledAETitle: configuration.calledAETitle,
            host: host,
            port: port,
            maxPDUSize: configuration.maxPDUSize,
            implementationClassUID: configuration.implementationClassUID,
            implementationVersionName: configuration.implementationVersionName,
            timeout: configuration.timeout
        )
        
        // Create association
        let association = Association(configuration: associationConfig)
        
        // Create presentation context for Storage Commitment
        let presentationContext = try PresentationContext(
            id: 1,
            abstractSyntax: storageCommitmentPushModelSOPClassUID,
            transferSyntaxes: [
                explicitVRLittleEndianTransferSyntaxUID,
                implicitVRLittleEndianTransferSyntaxUID
            ]
        )
        
        do {
            // Establish association
            let negotiated = try await association.request(presentationContexts: [presentationContext])
            
            // Verify that Storage Commitment was accepted
            guard negotiated.isContextAccepted(1) else {
                try await association.abort()
                throw DICOMNetworkError.sopClassNotSupported(storageCommitmentPushModelSOPClassUID)
            }
            
            // Perform the N-ACTION request
            let response = try await performNAction(
                association: association,
                presentationContextID: 1,
                maxPDUSize: negotiated.maxPDUSize,
                transactionUID: transactionUID,
                references: references
            )
            
            // Check response status
            guard response.status.isSuccess else {
                try await association.abort()
                throw DICOMNetworkError.queryFailed(response.status)
            }
            
            // Release association gracefully
            try await association.release()
            
            // Return the commitment request
            return CommitmentRequest(
                transactionUID: transactionUID,
                references: references,
                remoteAETitle: configuration.calledAETitle.value
            )
            
        } catch {
            // Attempt to abort on error
            try? await association.abort()
            throw error
        }
    }
    
    /// Parses a commitment result from an N-EVENT-REPORT data set
    ///
    /// This method parses the data set received in an N-EVENT-REPORT request
    /// to extract the commitment result information.
    ///
    /// - Parameters:
    ///   - eventTypeID: The event type ID (1 = success, 2 = failures exist)
    ///   - dataSet: The data set containing commitment results
    ///   - remoteAETitle: The AE title of the sender
    /// - Returns: The parsed commitment result
    /// - Throws: `DICOMNetworkError.decodingFailed` if parsing fails
    public static func parseCommitmentResult(
        eventTypeID: UInt16,
        dataSet: Data,
        remoteAETitle: String
    ) throws -> CommitmentResult {
        // Parse Transaction UID (0008,1195)
        guard let transactionUID = extractUIValue(from: dataSet, tag: Tag(group: 0x0008, element: 0x1195)) else {
            throw DICOMNetworkError.decodingFailed("Missing Transaction UID in commitment result")
        }
        
        var committedReferences: [SOPReference] = []
        var failedReferences: [FailedSOPReference] = []
        
        // Parse Referenced SOP Sequence (0008,1199) - committed instances
        if let sequenceItems = extractSequenceItems(from: dataSet, tag: Tag(group: 0x0008, element: 0x1199)) {
            for item in sequenceItems {
                if let sopClassUID = extractUIValue(from: item, tag: Tag(group: 0x0008, element: 0x1150)),
                   let sopInstanceUID = extractUIValue(from: item, tag: Tag(group: 0x0008, element: 0x1155)) {
                    committedReferences.append(SOPReference(
                        sopClassUID: sopClassUID,
                        sopInstanceUID: sopInstanceUID
                    ))
                }
            }
        }
        
        // Parse Failed SOP Sequence (0008,1198) - failed instances
        if let sequenceItems = extractSequenceItems(from: dataSet, tag: Tag(group: 0x0008, element: 0x1198)) {
            for item in sequenceItems {
                if let sopClassUID = extractUIValue(from: item, tag: Tag(group: 0x0008, element: 0x1150)),
                   let sopInstanceUID = extractUIValue(from: item, tag: Tag(group: 0x0008, element: 0x1155)) {
                    let failureReason = extractUSValue(from: item, tag: Tag(group: 0x0008, element: 0x1197)) ?? 0x0110
                    failedReferences.append(FailedSOPReference(
                        reference: SOPReference(
                            sopClassUID: sopClassUID,
                            sopInstanceUID: sopInstanceUID
                        ),
                        failureReason: failureReason
                    ))
                }
            }
        }
        
        return CommitmentResult(
            transactionUID: transactionUID,
            committedReferences: committedReferences,
            failedReferences: failedReferences,
            remoteAETitle: remoteAETitle
        )
    }
    
    // MARK: - Private Helpers
    
    /// Performs the N-ACTION request/response exchange
    private static func performNAction(
        association: Association,
        presentationContextID: UInt8,
        maxPDUSize: UInt32,
        transactionUID: String,
        references: [SOPReference]
    ) async throws -> NActionResponse {
        // Build the action data set
        let actionDataSet = buildCommitmentRequestDataSet(
            transactionUID: transactionUID,
            references: references
        )
        
        // Create N-ACTION request
        let request = NActionRequest(
            messageID: 1,
            requestedSOPClassUID: storageCommitmentPushModelSOPClassUID,
            requestedSOPInstanceUID: storageCommitmentPushModelSOPInstanceUID,
            actionTypeID: storageCommitmentRequestActionTypeID,
            hasDataSet: true,
            presentationContextID: presentationContextID
        )
        
        // Fragment and send the command and data
        let fragmenter = MessageFragmenter(maxPDUSize: maxPDUSize)
        let pdus = fragmenter.fragmentMessage(
            commandSet: request.commandSet,
            dataSet: actionDataSet,
            presentationContextID: presentationContextID
        )
        
        // Send all PDVs
        for pdu in pdus {
            for pdv in pdu.presentationDataValues {
                try await association.send(pdv: pdv)
            }
        }
        
        // Receive response
        let assembler = MessageAssembler()
        
        while true {
            let responsePDU = try await association.receive()
            
            if let message = try assembler.addPDVs(from: responsePDU) {
                guard message.command == .nActionResponse else {
                    throw DICOMNetworkError.decodingFailed(
                        "Expected N-ACTION-RSP, got \(message.command?.description ?? "unknown")"
                    )
                }
                return NActionResponse(commandSet: message.commandSet, presentationContextID: presentationContextID)
            }
        }
    }
    
    /// Builds the data set for a storage commitment request
    private static func buildCommitmentRequestDataSet(
        transactionUID: String,
        references: [SOPReference]
    ) -> Data {
        var dataSet = Data()
        
        // Transaction UID (0008,1195) - UI
        dataSet.append(encodeUIElement(tag: Tag(group: 0x0008, element: 0x1195), value: transactionUID))
        
        // Referenced SOP Sequence (0008,1199) - SQ
        let referencedSOPSequenceTag = Tag(group: 0x0008, element: 0x1199)
        var sequenceData = Data()
        
        for reference in references {
            var itemData = Data()
            
            // Referenced SOP Class UID (0008,1150) - UI
            itemData.append(encodeUIElement(tag: Tag(group: 0x0008, element: 0x1150), value: reference.sopClassUID))
            
            // Referenced SOP Instance UID (0008,1155) - UI
            itemData.append(encodeUIElement(tag: Tag(group: 0x0008, element: 0x1155), value: reference.sopInstanceUID))
            
            // Encode item
            sequenceData.append(encodeSequenceItem(itemData))
        }
        
        // Append sequence delimiter
        sequenceData.append(encodeSequenceDelimiter())
        
        // Encode sequence element with undefined length
        dataSet.append(encodeSequenceElement(tag: referencedSOPSequenceTag, content: sequenceData))
        
        return dataSet
    }
    
    /// Encodes a UI element in Explicit VR Little Endian
    private static func encodeUIElement(tag: Tag, value: String) -> Data {
        var data = Data()
        
        // Tag (4 bytes, little endian)
        var group = tag.group.littleEndian
        var element = tag.element.littleEndian
        data.append(Data(bytes: &group, count: 2))
        data.append(Data(bytes: &element, count: 2))
        
        // VR (2 bytes)
        data.append(contentsOf: "UI".utf8)
        
        // Pad value to even length
        var valueData = value.data(using: .ascii) ?? Data()
        if valueData.count % 2 != 0 {
            valueData.append(0x00)
        }
        
        // Length (2 bytes for UI)
        var length = UInt16(valueData.count).littleEndian
        data.append(Data(bytes: &length, count: 2))
        
        // Value
        data.append(valueData)
        
        return data
    }
    
    /// Encodes a sequence item
    private static func encodeSequenceItem(_ itemData: Data) -> Data {
        var data = Data()
        
        // Item tag (FFFE,E000)
        data.append(contentsOf: [0xFE, 0xFF, 0x00, 0xE0])
        
        // Item length (4 bytes, little endian)
        var length = UInt32(itemData.count).littleEndian
        data.append(Data(bytes: &length, count: 4))
        
        // Item data
        data.append(itemData)
        
        return data
    }
    
    /// Encodes a sequence delimiter
    private static func encodeSequenceDelimiter() -> Data {
        var data = Data()
        
        // Sequence delimitation item (FFFE,E0DD)
        data.append(contentsOf: [0xFE, 0xFF, 0xDD, 0xE0])
        
        // Length (always 0)
        data.append(contentsOf: [0x00, 0x00, 0x00, 0x00])
        
        return data
    }
    
    /// Encodes a sequence element with undefined length
    private static func encodeSequenceElement(tag: Tag, content: Data) -> Data {
        var data = Data()
        
        // Tag (4 bytes, little endian)
        var group = tag.group.littleEndian
        var element = tag.element.littleEndian
        data.append(Data(bytes: &group, count: 2))
        data.append(Data(bytes: &element, count: 2))
        
        // VR (2 bytes)
        data.append(contentsOf: "SQ".utf8)
        
        // Reserved (2 bytes)
        data.append(contentsOf: [0x00, 0x00])
        
        // Undefined length (4 bytes)
        data.append(contentsOf: [0xFF, 0xFF, 0xFF, 0xFF])
        
        // Sequence content
        data.append(content)
        
        return data
    }
    
    /// Extracts a UI value from data at a specific tag
    private static func extractUIValue(from data: Data, tag: Tag) -> String? {
        var offset = 0
        
        while offset + 8 <= data.count {
            let group = UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
            let element = UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8)
            offset += 4
            
            // Check for explicit VR
            let byte0 = data[offset]
            let byte1 = data[offset + 1]
            let possibleVR = String(bytes: [byte0, byte1], encoding: .ascii) ?? ""
            
            let length: Int
            if possibleVR == "UI" || possibleVR == "SH" || possibleVR == "LO" ||
               possibleVR == "CS" || possibleVR == "AE" || possibleVR == "DA" ||
               possibleVR == "TM" || possibleVR == "DS" || possibleVR == "IS" ||
               possibleVR == "PN" || possibleVR == "AS" || possibleVR == "DT" ||
               possibleVR == "ST" || possibleVR == "LT" {
                // Short VR - 2 byte VR + 2 byte length
                length = Int(UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8))
                offset += 4
            } else if possibleVR == "OB" || possibleVR == "OW" || possibleVR == "OF" ||
                      possibleVR == "SQ" || possibleVR == "UC" || possibleVR == "UR" ||
                      possibleVR == "UT" || possibleVR == "UN" {
                // Long VR - 2 byte VR + 2 byte reserved + 4 byte length
                offset += 4
                length = Int(UInt32(data[offset]) |
                            (UInt32(data[offset + 1]) << 8) |
                            (UInt32(data[offset + 2]) << 16) |
                            (UInt32(data[offset + 3]) << 24))
                offset += 4
            } else {
                // Implicit VR - 4 byte length
                length = Int(UInt32(data[offset]) |
                            (UInt32(data[offset + 1]) << 8) |
                            (UInt32(data[offset + 2]) << 16) |
                            (UInt32(data[offset + 3]) << 24))
                offset += 4
            }
            
            if group == tag.group && element == tag.element {
                // Found the tag
                if length > 0 && offset + length <= data.count {
                    let valueData = data.subdata(in: offset..<(offset + length))
                    return String(data: valueData, encoding: .ascii)?
                        .trimmingCharacters(in: CharacterSet(charactersIn: " \0"))
                }
                return nil
            }
            
            // Skip value
            if length > 0 && length != 0xFFFFFFFF {
                offset += length
            }
        }
        
        return nil
    }
    
    /// Extracts a US (unsigned short) value from data at a specific tag
    private static func extractUSValue(from data: Data, tag: Tag) -> UInt16? {
        var offset = 0
        
        while offset + 8 <= data.count {
            let group = UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
            let element = UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8)
            offset += 4
            
            let byte0 = data[offset]
            let byte1 = data[offset + 1]
            let possibleVR = String(bytes: [byte0, byte1], encoding: .ascii) ?? ""
            
            let length: Int
            if possibleVR == "US" || possibleVR == "SS" || possibleVR == "AT" {
                length = Int(UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8))
                offset += 4
            } else {
                length = Int(UInt32(data[offset]) |
                            (UInt32(data[offset + 1]) << 8) |
                            (UInt32(data[offset + 2]) << 16) |
                            (UInt32(data[offset + 3]) << 24))
                offset += 4
            }
            
            if group == tag.group && element == tag.element {
                if offset + 2 <= data.count {
                    return UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
                }
                return nil
            }
            
            if length > 0 && length != 0xFFFFFFFF {
                offset += length
            }
        }
        
        return nil
    }
    
    /// Extracts sequence items from data at a specific tag
    private static func extractSequenceItems(from data: Data, tag: Tag) -> [Data]? {
        var offset = 0
        
        // Find the sequence tag
        while offset + 8 <= data.count {
            let group = UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
            let element = UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8)
            offset += 4
            
            let byte0 = data[offset]
            let byte1 = data[offset + 1]
            let possibleVR = String(bytes: [byte0, byte1], encoding: .ascii) ?? ""
            
            var sequenceLength: Int = 0
            if possibleVR == "SQ" {
                // Explicit VR SQ
                offset += 4 // Skip VR and reserved
                sequenceLength = Int(UInt32(data[offset]) |
                                    (UInt32(data[offset + 1]) << 8) |
                                    (UInt32(data[offset + 2]) << 16) |
                                    (UInt32(data[offset + 3]) << 24))
                offset += 4
            } else {
                // Implicit VR
                sequenceLength = Int(UInt32(data[offset]) |
                                    (UInt32(data[offset + 1]) << 8) |
                                    (UInt32(data[offset + 2]) << 16) |
                                    (UInt32(data[offset + 3]) << 24))
                offset += 4
            }
            
            if group == tag.group && element == tag.element {
                // Found the sequence - extract items
                var items: [Data] = []
                let sequenceEnd = sequenceLength == 0xFFFFFFFF ? data.count : offset + sequenceLength
                
                while offset < sequenceEnd && offset + 8 <= data.count {
                    let itemGroup = UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
                    let itemElement = UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8)
                    
                    if itemGroup == 0xFFFE && itemElement == 0xE000 {
                        // Item start
                        let itemLength = Int(UInt32(data[offset + 4]) |
                                            (UInt32(data[offset + 5]) << 8) |
                                            (UInt32(data[offset + 6]) << 16) |
                                            (UInt32(data[offset + 7]) << 24))
                        offset += 8
                        
                        if itemLength == 0xFFFFFFFF {
                            // Undefined length item - find delimiter
                            let itemStart = offset
                            while offset + 8 <= data.count {
                                let delimGroup = UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
                                let delimElement = UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8)
                                if delimGroup == 0xFFFE && delimElement == 0xE00D {
                                    items.append(data.subdata(in: itemStart..<offset))
                                    offset += 8
                                    break
                                }
                                offset += 1
                            }
                        } else if offset + itemLength <= data.count {
                            items.append(data.subdata(in: offset..<(offset + itemLength)))
                            offset += itemLength
                        }
                    } else if itemGroup == 0xFFFE && itemElement == 0xE0DD {
                        // Sequence delimiter
                        break
                    } else {
                        break
                    }
                }
                
                return items.isEmpty ? nil : items
            }
            
            // Skip to next element
            if sequenceLength > 0 && sequenceLength != 0xFFFFFFFF {
                offset += sequenceLength
            }
        }
        
        return nil
    }
}

#endif
